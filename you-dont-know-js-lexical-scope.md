---
title: "你不知道的 JS 「词法作用域」"
date: 2016-08-21 17:14:59
tags:
---

作用域有两种主要的工作模型，第一种叫**词法作用域**，大多数编程语言采用这种（JavaScript 同样也是）。另一种叫做**动态作用域**，有部分编程语言在使用。

词法作用域

## 作用域查找
作用域的结构和互相之间的位置关系给引擎提供了足够的位置信息，引擎用这些信息来查找标识符的位置。

作用域查找会在找到第一个匹配的标识符时停止。在嵌套的作用域中科院定义同名的标识符，这叫做“遮蔽效应”。非全局变量如果被遮蔽了，无论如何都无法被访问。全局变量可以通过全局对象的属性访问。

**无论函数在哪里调用，也无论如何调用，他的词法作用域都只由函数被声明时所处的位置决定。**

<!-- more -->

## 如何欺骗词法
JavaScript 中有两种方式来实现欺骗词法作用域，但是不建议在代码中使用。**欺骗词法作用域会导致性能下降。**

欺骗词法作用域会使得引擎在编译时无法对作用域查找进行优化，由于词法作用域可能会被修改，所以最好的优化就是不优化，而这样就会导致性能的降低。

### eval
JavaScript 中的 `eval()` 函数类似于 PHP 中的 `eval()`，即可以接受一段字符串，并运行这段字符串。也就是可以在代码中用 `eval()` 函数生成代码并运行，就好像原来就写在那里一样。

 ``` js
 function foo(str, a) {
  eval(str);
  console.log(a, b);  
 }
 
 var b = 2;
 
 foo('var b = 3;', 1);  // 1, 3
 ```

上面的代码在实际运行中会变成这样：

``` js
function foo(a) {
  var b = 3;
  console.log(a, b);  
 }
 
 var b = 2;
 
 foo(1);  // 1, 3
```

看起来就像是原本就在代码中的一样，不同的是这个 `eval()` 传入的参数是会动态变化的，不能完全确定它到底是什么。但是 `eval()` 运行却能够修改运行时的作用域。

不过幸好，在严格模式中，`eval()` 在运行时有自己的词法作用域，这样就意味着 `eval()` 中运行的代码无法改变所在的作用域。这样就会有运行时被修改所在的作用域而产生奇怪的错误了。

### with
另外一个能够欺骗词法作用域的是 `with` 关键字。`with` 可以将一个没有或有多个属性的对象处理为一个完全隔离的词法作用域。

``` js
function foo(obj) {
  with(obj) {
    a = 2;
  }
}

var o1 = {
  a: 3
};

var o2 = {
  b: 3
};

foo(o1);
console.log(o1.a); // 2

foo(o2);
console.log(o2.a); // undefined
console.log(a); // 2
```

`with` 可以将一个对象处理为词法作用域，但是这个块内部的正常的 var 声明并不会被限制在这个块中。而是添加到 `with` 所处的作用域中。

## 小结
词法作用域意味着作用域是由书写代码时声明的位置来确定的。

JavaScript 中有两个用来欺骗词法作用域的机制：`eval()` 与 `with`，但是使用它们会导致性能降低，而且可能产生某些难以察觉的错误。

**仅了解 `eval()` 与 `with`，但是不要使用它们。**


