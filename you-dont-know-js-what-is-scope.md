---
title: "你不知道的 JS「作用域是什么」"
date: 2016-08-16 15:17:55
tags:
  - JavaScript
---

尽管 JavaScript 被归类为「动态」或者「解释执行」语言，但事实上它是一门**编译语言**。但与传统的编译（C, Java）不同，它不是提前编译的。

所谓「解释执行」并不是不用编译，而只是不需要用户显式去使用编译器得到可执行代码而已。 

## 编译
JavaScript 引擎编译的步骤与传统的编译语言非常相似，传统编译语言的代码在执行之前会进行三个步骤，统称为「编译」。
<!-- more -->

- 词法分析（Tokenizing / Lexing）：将字符组成的字符串分解成有意义的代码块，称为词法单元（token）。
- 语法分析（Parsing）：将词法单元流转换成一个由元素逐级嵌套组成的树，表示程序的语法结构，称为「抽象语法树」（Abstract Tree, AST）。
- 代码生成：将抽象语法书转换为可执行的代码。

> 编译的大概过程可以参考这个用 JavaScript 实现的最小编译器：[the-super-tiny-compiler](https://github.com/thejameskyle/the-super-tiny-compiler)

实际上 JavaScript 引擎并没有这么简单，并且不会有大量的实际进行优化，因为 JavaScript 编译的过程是在执行前进行的，编译后马上就会执行。

##  LHS 与 RHS 
变量的赋值操作会执行两个动作，如果变量在之前没有声明过，则编译器会在当前的作用域中声明这个变量，然后运行时引擎会在作用域中查找该变量，如果能够找到则对它赋值。

在引擎在对变量赋值的时候会进行 `LHS` 查询，对应的有一个查找的类型叫做 `RHS`。`RHS` 查询与简单的查找相同，而 `LHS` 则是试图找到该变量的本身，然后对其赋值。

可以把这两种查找简单理解为：

- LHS（Left-hand Side）：查找赋值操作的目标，即等号左边的引用。
- RHS（Right-hand Side）：查找赋值操作的源头，即等号右边的引用。

考虑下面的这段代码进行了几次 LHS 与 RHS 查询：

``` js
function foo(a) {
  var b = a;
  return a + b;
}

var c = foo(2);
```

LHS 查询3次：对 c 赋值时、对 foo 函数传值时（隐式变量分配）、在 foo 函数中对 b 赋值时。

RHS 查询4次：对 c 赋值时 foo 的引用，对 b 赋值时 a 的引用，函数 foo 返回时对 a 与 b 的引用。

## 作用域嵌套
当一个块或者函数嵌套在另一个块或者函数中时，就发生了作用域嵌套。当在当前作用域中无法找到某个变量时，引擎就会向外层的作用域中继续查找，直到查找到该变量，或者到达全局作用域为止。

`LHS` 与 `RHS` 都会在当前的作用域中查找，查找不到则往外层的作用域查找，直到查找结束。但是 `RHS` 在查找了所有作用域之后还没有找到该变量的话会抛出 `ReferenceError` 异常，表示这是一个还没有声明的变量。

`LHS` 查找在非严格模式下，查找到全局作用域还无法找到目标变量时，会创建一个具有该名称的全局变量，并返回给引擎。也就是说，在给未声明的变量赋值时，全局作用域就会自动创建一个全局变量（即没有使用 `var` 声明并赋值）。

``` js
function foo() {
  a = 2;
}

foo();
console.log(a);  //  2
```

在函数 `foo` 的作用域下进行 `LHS` 查找，没有查找到名为 `a` 的变量，继续向外层作用域查找（此时已经是全局作用域）。在全局作用域下同样也没有找到名为 `a` 的变量。在非严格模式下，自动在全局作用域下创建名为 `a` 的变量。接着进行 `RHS` 查找，在全局作用域下找到 `a`，并对 `a` 赋值为 2。

如果启用严格模式（`"use strict"`），则不会自动或者隐式的创建全局变量。并且 `LHS` 查询会与 `RHS` 查询失败时相同，抛出 `ReferenceError` 异常。

> 抛出 TypeError 异常时，说明作用域判别成功，即查询到了变量，但是对这个变量的值进行了不合理的操作。

## 小结
作用域是一套用于确定在何处以及如何查找变量的规则。如果查找的目的是对变量赋值，那么就使用 `LHS` 查询；如果目的是查找变量的值，就会使用 `RHS` 查询。






 




