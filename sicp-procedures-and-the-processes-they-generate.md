---
title: SICP 过程与它们所产生的计算
date: 2016-07-08 23:38:00
tags:
  - SICP
  - Scheme
---

## 线性的递归和迭代

对于阶乘，我们的表达式定义是：n! = n * (n - 1) ... * 3 * 2 * 1

### 线性递归过程
阶乘可以看做为，`n! = n * (n-1)!`
<!-- more -->

通过这个定义，我们可以得到：

``` scheme
(define (factorial n)
  (if (= n 1)
      1
      (* n (factorial (- n 1)))))
```

通过代换模型，我们的计算过程将会是把表达式展开到无法展开，然后再进行数值的计算。在这样的计算过程中会构造起进行操作的链条，即展开到无法展开时的那一串乘法链条。要执行这种操作，解释器必须维护那些所需要保持的信息。信息量随着n值线性增长。这样的计算过程称为**线性递归过程**。

### 线性迭代过程
除了上面的这种计算方式之外，还可以将阶乘看成是 1 * 2 的结果再乘以 3，再使用它们产生的结果乘以 4，以此类推，直到乘以 n。

那么就可以得到：

``` scheme
(define (factorial n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product)
              (+ counter 1)))))
```

再次通过代换模型，这个计算过程将不会构造之前所说的链条，而只需要维护 `product` 与 `counter` 即可。这种过程称为**迭代计算过程**，即那种其状态可以用固定数目的状态变量描述的计算过程。

（上面的这种过程类似于其他编程语言中 `for` 循环的计算过程，`for` 的计算过程看起来也是一个迭代计算过程）

计算过程从一个状态到下一个状态转换时，这些变量的更新方式，以及可能有的结束检查，描述计算过程的终止条件。所需要的计算步骤随着n值得增长而增长，这种过程称为**线性迭代过程**。

## 树形递归
还有一种计算模式称为**树形递归**。关于树形递归是什么样的，可以参考斐波那契数列的计算，使用 Lisp 定义为：

``` scheme
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

这样的计算过程，当计算 `(fib 5)` 的时候需要先计算 `(fib 4)` 与 `(fib 3)`，而计算 `(fib 4)` 又需要计算 `(fib 3)` 和 `(fib 2)`。以此类推，展开之后就是一个树形的计算过程。

但是，这样的计算过程做了太多的冗余计算，计算 `(fib 5)` 时需要计算 `(fib 3)`，而计算 `(fib 4)` 时也需要，这里 `(fib 3)` 就做了多余的一次操作。这样，计算过程的步骤就随着输入的增长而指数增长。

一般来说，树形递归计算过程里所需要的步骤数正比于树中的节点数，其空间需求正比于树的最大深度。

可以将上面的斐波那契数列的计算使用另外一种方法计算，这种方法是**线性迭代**。以此类推，展开之后就是一个树形的计算过程。

``` scheme
(define (fib n)
  (fib-iter 1 0 n))

(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
```

## 欧几里得算法
对于计算两个整数的最大公约数，我们会使用欧几里得算法，也就是辗转相除法来求。

欧几里得算法：如果 r 是 a 除以 b 的余数，那么 a 和 b 的最大公约数正好也是 b 与 r 的最大公约数。

使用 Lisp 表示这一计算过程：

``` scheme
(define (gcd a b)
  (if (= b 0)
      a
      (gcd b (remainder a b))))
```

`remainder` 是 scheme 中的基本过程，其作用是求模。

## 费马检查
对于素数的检测，常用的算法是同从2开始的整数去检查它们是否能够整除 n，若有任意一个数能够整除，那该数即不是素数。

而又另外一种素数的检测方法，但是这种方法只能确定该数是素数的可能性很大，通过检查的次数越多概率越高，理论上当概率足够大时即可以认为该数为素数。这种方法称为费马检查，费马检查依赖于费马小定理。

费马小定理：如果 n 是一个素数，a 是小于 n 的任意正整数，那么 a 的 n 次方与 a 模 n 同余，即是 `a^n%n == a%n`。
