---
title: SICP 程序设计的基本元素
date: 2016-07-02 21:10:16
tags:
  - SICP
  - Scheme
---

## 前言
买了近一年的《计算机程序的构造和解释》（Structure and Interpretation of Computer Programs，俗称 SICP），到现在也只是看过一两章。现在连前两章讲的内容都忘记了。趁着这个暑假晚上一个人，把这本书看一遍。顺带着在博客上写写笔记。

### 关于 Scheme
Scheme 是一种 Lisp 方言，在这本书中将会使用该语言来描述。Lisp 是一种历史第二悠久的编程语言，也是一种函数式编程语言。具体信息见：[Lisp - wikipedia](https://zh.wikipedia.org/wiki/LISP)。

<!-- more -->

## 程序设计的基本元素
> 一个强有力的程序设计语言，不仅是一种指挥计算机执行任务过程的方式，它还应该成为一种框架，使我们能够在其中组织自己有关计算过程的思想。

每种强有力的语言都会提供三种机制：
- 基本的表达形式
- 组合的方法
- 抽象的方法

### 表达式

可以输入的一种最基本的表达式就是数，即由数字组成的表达式，它表示的是以10为基数的数。可以使用基本的过程表达形式将表达数的表达数组合起来，形成符合表达式，即组合式。

``` scheme
(+ 137 349)
486

(* 5 100 2)
100
```

scheme 使用的这种将所有运算符放在左边的形式称为前缀表达式。与常规的中缀表达式不同，前缀表达式使用于可能带有任意个实参的过程，同时它还可以直接扩充，可以出现组合式嵌套的形式。

``` scheme
(+ (* 3 5) (- 10 6))
19
```

这样就可以讲组合式本身当成元素提供给另外一个组合式，这样就有了组合的方式了。

### 命名和环境
程序设计语言中必不可少的就是提供对计算对象命名的方式，即拥有变量的概念。

在 scheme 中，给事物命名通过 `define` 来完成，即：

``` scheme
(define (size 2))

size
2
```

也就是说可以通过 `define 名字 表达式` 的方式来将名字与表达式关联。这里的 define 即是一种抽象的方法，将表达式抽象出一个名称。

> 实际上，构造一个复杂的程序，也就是为了去一步步地创建出越来越复杂的计算性对象。解释器使得这种逐步的程序构建过程变得非常方便，因为我们可以通过一系列交互式动作，逐步创建起所需要的名字-对象关联。

将值与符号关联，又能够获取这些值，就是说解释器需要去维护某种储存能力，以便保持值与符号的联系。这种存储称之为**环境**。

### 组合式的求值

对组合式求值需要以下步骤：
- 求值该组合式的各个子表达式
- 将运算符应用于相应的其他子表达式的值

将每个子表达式看成一棵树，表达式中的各个部分为树的子叶，表达式的值为树的根。接着讲子表达式组合在一起形成一颗大树，该树的根即为这个组合式的值。计算过程以递归的形式“值向上穿行”，这种计算过程称为**树形积累**。

``` scheme
(* (+ 5 1) (- 4 2))

             12
          /   |   \
        *    6      2
           / | \  / | \
          +  5 1 -  4  2
```

### 复合过程

过程定义可以为复合操作提供名字，而后就可以将复合操作作为一个单元来使用。函数定义就是过程定义，通过函数定义可以为复合操作过程提供一个名称，之后就可以通过函数调用来使用这一定义了的复合操作。

定义与调用平方的过程
``` scheme
(define (square x) (* x x))

(square 21)
441
```

过程定义的一般形式是：`(define (名称 参数) 主体)`。这就像是其他编程语言中的函数定义一样，需要定义函数名称，给定形参，确定函数体。然后可以将定义了的复合操作过程当做基本构件去定义其他的过程。

例如：x^2 + y^2
``` scheme
(+ (square x) (square y))
```

然后可以进一步的定义这个过程
``` scheme
(define (sum-of-squares x y)
  (+ (square x) (square y)))

(sum-of-squares 3 4)
25
```

这样就可以通过构建简单的复合操作，再通过简单的复合操作定义作为基础构件定义更为复杂的复合过程。

### 过程应用的代换模型

对组合求值的工作方式是将复合过程应用于实际参数，就是将过程中的每个形参用相应的实参取代后，运用之前所说的树形累积的方式求值。

对 `sum-of-squares` 这一过程进一步的定义
``` scheme
(define (f a)
  (sum-of-squares (+ a 1) (* a 2)))
```

那么对 `(f 5)` 的求值过程就是：
``` scheme
# 实参代换相应的形参
(sum-of-squares (+ 5 1) (* 5 2))

# 对运算对象求值得到：
(sum-of-squares 6 10)

# sum-of-squares 被归约为：
(+ (square 6) (square 10))

# square 归约为：
(+ (* 6 6) (* 10 10))

# 最后得到
(+ 36 100)
136
```

这样的计算过程称为过程应用的代换模型，即一步步带入数据至基本计算过程。这种“先求值参数后应用”的求值名被称作**应用序求值**。还有另一种求值模型是先不求出运算对象的值，直到实际需要的时候再去计算，这样的求值模型被称为**正则序求值**。

正则序求值求上述例子：
``` scheme
# 逐步展开
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)))
(+ (* (+ 5 1) (+ 5 1) (* (* 5 2) (* 5 2))))

# 当无法再展开的时候进行归约
(+ (* 6 6) (* 10 10))
(+ 36 100)
136
```

Lisp 采用应用序求值，不用正则序的原因是正则序求值对表达式会有重复求值，减低了效率。

### 条件表达式和谓词
在编程语言中条件表达式是必不可少的。我们需要对不同情况做一个检测，也称为分情况分析。Lisp 中有针对这种分情况分析的特殊形式，也即是类似于其他编程语言的条件语句差不多的东西。在 Lisp 中被称为 `cond`。

例如需要实现计算出一个数的绝对值
``` scheme
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```

在 `cond` 之后跟着一些子句，每个子句对应这不同的情况，子句是使用括号括起来的表达式对偶，在每个表达式对偶中的第一个表达式被称为谓词，它的值被解释成真或者假。有点类似与其他语言中的 `switch` 语句，不同的是当所有值都为假时，没有默认执行的项。

对于上面的绝对值计算，还可以这样写
``` scheme
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
```

`else` 可以放在 `cond` 最后一个子句中，能够起到当前面的所有子句都未假时，会执行 `else` 后的内容。可以当做是其他语言中的 `if...else...`。

另外求绝对值还可以这样写：
``` scheme
(define (abs x)
  (if (< x 0)
      (- x)
      x ))
```

看起来像是 `if...else...` 的形式，但个人觉得更像是其他语言中的三目运算。当 if 后的谓词值为真时执行第一个表达式，否则就执行第二个。

`>`,`=`,`<` 都称为基本谓词，接受两个数为参数，返回真或者假。另外还有其他的一些逻辑复合运算符，使用这些能够组成出各种复合谓词。常用的复合运算符有：`and`、`or`、`not`，其含义即为与，或，非。

检查某个数是否大于等于另外一个数
``` scheme
(define (>= x y)
  (or (< x y) (= x y)))
```

### 牛顿法求平方根
在计算机中求平方根最常用的方法就是使用牛顿的逐步逼进方法。如果对 x 的平方根有一个猜测值 y，那么可以通过一个操作去得到更好的一个猜测：只需要求出 y 与 x/y 的平均值，再使用平均值再一次逼近 x 的平方根。这样能够得到对 x 的平方根越来越好的近似值。

scheme 的实现为：
``` scheme
(define (average x y)
  (/ (+ x y) 2))

(define (improve guess x)
  (average guess (/ x guess)))

(define (good-enough? guess x)
  (< (abs (- (square guess) x))
      0.001)

(define (sqrt-iter guess x)
  (if (good-enough? guess x)
      guess
      (sqrt-iter (improve guess x)
                  x )))

(define (sqrt x)
  (sqrt-iter 1.0 x))
```

### 过程作为黑箱抽象

对上述的平方根计算问题可以自然的分成若干的小问题。这些过程可以看成是中间的若干个小过程完成的。能够分解，使得每一个过程都能够完成一件可以清楚标明的工作，这使得它们可以被用作定义其他过程的模块，并且我们无须关注这些过程的具体过程，这就是所谓的**过程抽象**。

#### 局部名
局部名是实现细节中的形参，这个实现的细节是用户不需要关心的，局部名的名字是由这个黑箱的实现者决定的。

一个过程的定义约束了它的所有形式参数，即称之为**约束变量**。也就是说如果参数不是局部与有关的过程体，那么它就是约束变量。反之，如果在一个完整的过程里为某个变量换名，过程的意义也不会改变的话，称之为**自由变量**。

一个名字的定义被约束于那一级表达式称为这个名字的**作用域**。

#### 内部定义和块结构
在上述的球平方根程序中，`sqrt` 这一过程的其他子过程对用户来说并不重要。所以也需要能够将子过程给局部化，使得 `sqrt` 整个过程对于用户来说是黑箱。为了使其成为可能，允许在一个过程中去定义所需要用到的子过程，它们局部于这一个过程。

求平方根的过程可以重写为：
``` scheme
(define (sqrt x)
  (define (improve guess x)
    (average guess (/ x guess)))

  (define (good-enough? guess x)
    (< (abs (- (square guess) x))
        0.001)

  (define (sqrt-iter guess x)
    (if (good-enough? guess x)
        guess
        (sqrt-iter (improve guess x)
                    x )))

  (sqrt-iter 1.0 x))
```

这种嵌套的定义称之为块结构，在这个快结构中可以发现在整个过程的子过程中都使用了 x, 此时的 x 是受约束的，我们可以将 x 作为这一个过程内部的自由变量。

``` scheme
(define (sqrt x)
  (define (improve guess)
    (average guess (/ x guess)))

  (define (good-enough? guess)
    (< (abs (- (square guess) x))
        0.001)

  (define (sqrt-iter guess)
    (if (good-enough? guess)
        guess
        (sqrt-iter (improve guess))))

  (sqrt-iter 1.0 x))
```

这样，在外围的 `sqrt` 被调用时，x 由实际参数得到自己的值，这一方式称之为**词法作用域**。

> 词法作用域：要求过程中的自由变量实际引用外围过程定义中所出现的约束，也就是说，应该在定义本过程的环境中去寻找它们。

这种结构类似于其他编程语言中的类结构，拥有局部的内部方法以及内部变量。
